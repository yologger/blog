---
title: "Java 면접 정리"
lang: ko
showOnSidebar: true
sidebarDepth: 0
---

# Table of Contents
[[toc]]

# Java 면접 정리
`Java` 면접 내용을 정리합니다.

## Compiler vs. Interpreter
- `Compiler`: 컴파일러는 소스 코드를 기계어로 컴파일한다. 컴파일러 언어는 소스 코드를 컴파일하는 과정이 필요하다. 예를 들어 c언어는 `.c` 확장자의 소스코드는 `gcc`컴파일러로 컴파일하여 `.o`확장자의 오브젝트 파일이라는 실행 파일을 생성한다.
- `Interpreter`: 인터프리터 언어 소스 코드를 컴파일하는 과정이 필요없으며, 인터프리터가 소스 코드를 한 줄씩 읽어서 실행한다. 예를 들어 JavaScript 언어는 크롬 V8 런타임이 소스코드를 한 줄씩 읽어 실행한다.
- Java는 두 특성을 모두 가진 언어다. 소스코드를 컴파일하여 오브젝트 파일을 생성한다는 점에서 컴파일 언어다. 또한 JVM의 클래스로더가 오브젝트 파일을 한 줄씩 실행한다는 점에서 인터프리터 언어의 특성도 가지고 있다.

## JVM, JRE, JDK
- `JVM`: 바이트 코드를 기계어로 변환하여 실행한다.
- `JRE`: JVM에 Java API
- `JDK`: JRE + 개발과 관련된 도구

## JVM 메모리구조
- 클래스 파일을 메모리에 로드하는 `Class Loader`
- 클래스 파일이 로드되는 `Runtime Data Area`
- Runtime data area를 실행하는 `Execution Engine`
- 참조가 없는 인스턴스를 삭제하는 `Garbage Collector`
- `Runtime Data Area`는 다섯 부분으로 나뉜다.
    - 메소드, 클래스, 인터페이스, Static 변수, 상수가 배치되는 `Method`영역. 모든 스레드가 공유한다.
    - 동적 할당 영역인 `Heap`영역. 모든 스레드가 공유한다.
    - 지역변수와 파라미터가 저장되는 `Stack`영역
    - 멀티 스레드 환경에서 각 스레드가 현재 실행 중인 명령어의 주소를 저장하는 `PC Register` 영역
    - C/C++ 같이 Java 외의 언어로 작성된 코드가 배치되는 `Native Method`영역

## final
키워드 `final`은 세 가지 용도로 사용된다.
- 변수 앞에 붙이면 변경 불가능한 상수
- 메소드 앞에 붙이면 오버라이드 불가능한 메소드
- 클래스 앞에 붙이면 상속 불가능한 메소드

## Unchecked Exception vs. Checked Exception
- `Unchecked Exception`은 예외처리를 강제하지 않는 예외
- `Checked Exception`은 예외처리를 강제하는 예외

## 제너릭
- 클래스 내부에서 사용되는 변수의 타입을 클래스 외부에서 지정하는 것
- 제너릭을 사용하면 세 가지 장점이 있다.
    - 타입에 종속되지 않은 유연한 로직. `Collection`
    - 자동 형변환. (vs. `Object`)
    - 타입 안정성. (vs. `Object`). 컴파일 타임에 에러를 찾아낼 수 있다.

## 어노테이션
- 컴파일러에게 컴파일 타임이나 런타임에 특정 처리를 하도록 정보를 제공하는 것
- 컴파일 과정에서 경고나 에러를 감지하도록 컴파일러에게 정보를 제공
- 컴파일 과정에서 특정 코드를 생성하도록 컴파일러에게 정보를 제공
- 런타임에서 특정 기능을 실행하도록 정보를 제공

## 직렬화
- 객체를 스트림으로 입출력하기 위해서 바이트 배열로 변환하는 것
- 바이트 배열을 객체로 변환하는 것을 `역직렬화`라고 한다.
- 직렬화할 클래스는 `Serializable` 인터페이스를 구현해야한다.

## 얕은 복사 vs. 깊은 복사
- `얕은 복사`는 두 참조 변수가 같은 인스턴스를 참조하는 것
- `깊은 복사`는 동일한 인스턴스를 새롭게 생성하는 것

## 동일성과 동등성
### 동일성
`동일성(Identity)`는 두 객체의 주소값이 같다는 것을 의미한다. `==` 연산자 또는 `hashcode()` 메소드의 값이 동일하면 두 객체는 동일하다고 한다.

### 동등성
`동등성(Equality)`는 두 객체의 속성값이 같다는 것을 의마한다. `Object` 클래스의 `equal()`메소드를 구현하여 두 객체가 동등한지 판별할 수 있다.

## 가변 객체 vs. 불변 객체
- `가변 객체`는 객체를 생성한 후 상태를 바꿀 수 있는 객체를 의미한다.
- `불변 객체`는 객체를 생성한 후 상태를 바꿀 수 없는 객체를 의미한다.
- 불변 객체를 사용하면 다음과 같은 장점이 있다.
    - 상태를 변경할 수 없기 때문에 멀티 스레드 환경에서 안전한다.
    - 사이드 이펙트를 방지할 수 있다.

## 함수형 인터페이스
- 객체지향 프로그래밍인 Java에 함수형 프로그래밍 패러다임을 적용하기 위해 Java 8에서 도입된 기능
- 함수형 인터페이스는 단 하나의 추상 메소드를 가지고 있는 인터페이스에 `@FunctionalInterace` 어노테이션을 붙여주면 된다.
- 함수형 인터페이스 타입의 변수에는 람다식을 할당할 수 있다.
- 함수형 인터페이스 타입의 파라미터에는 람다식을 전달할 수 있다.
- 함수형 인터페이스 타입의 반환값으로 람다식을 전달할 수 있다.

## 리플렉션
런타임에 클래스의 구체적인 타입을 몰라도 그 클래스의 멤버변수, 메소드 등을 분석하고 접근할 수 있도록 하는 자바 API와 기법이다

### 클래스 참조
Java의 모든 클래스와 인터페이스는 컴파일 후 `.class`파일로 변환된다. 이 파일에는 생성자, 멤버변수, 메서드 등 객체의 정보가 포함되어있는데 `Class`클래스를 사용하면 이 파일에서 가져온 객체의 정보를 담을 수 있다. 이를 `클래스 참조(Class Reference)`라고 한다.
``` java
String str = new String();
Class clazz = str.getClass()
```

### 메소드 참조
Java 8부터 추가된 기능으로 람다식이 오직 하나의 메소드만을 호출하는 경우 `메소드 참조`를 사용하여 단축할 수 있다. 메소드 참조는 `콜론 두 개(::)`를 사용한다.
``` java
Lambda lambda = (something) -> System.out.println(something);
```
``` java
Lambda lambda = System.out::println;
```

### 생성자 참조
Java 8부터 추가된 기능으로 생성자 호출을 `생성자 참조`를 사용하여 단축할 수 있다.
``` java
Lambda lambda = (str) ->  new Person(str);
```
``` java
Lambda lambda = Person::new;
```

## Optional API
`Optional`은 Java 8에 추가된 기능으로, `NullPointException`을 쉽게 핸들링할 수 있다. `null`이 발생할 수 있는 객체를 `Optional`로 래핑한 후 `isPresent()`, `ifPresent()` 메소드로 `null` 체크를 할 수 있다.

## Stream API
Java 8에 추가된 기능으로 Array 또는 Collection과 이터레이션 등을 더욱 쉽게 처리할 수 있다.

## default 메소드
`default 메소드`를 사용하면 인터페이스에도 메소드를 구현할 수 있다. 이 기능을 사용하여 하위 호완성을 확보할 수 있다.

## JDBC
- Java에서 데이터베이스 연결 및 조작을 위한 자바 API입니다. 