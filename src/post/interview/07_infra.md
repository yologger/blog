---
title: "Infra 면접 정리"
lang: ko
showOnSidebar: true
sidebarDepth: 0
---

# Table of Contents
[[toc]]

  
## Domain Driven Design
- 도메인 주도 설계(Domain Driven Design)
- 도메인, 현업의 비즈니스를 중심으로 하는 프로그래밍
- 기존에는 기획팀, 디자인팀, 개발팀, 인프라팀, 도메인 팀으로 구성되었다면 DDD는 도메인 단위로 팀을 구성한다.
- 예를 들어 결제와 관련된 기능을 구현할 때 관련된 기획자, 디자이너, 프론트엔드 개발자, 백엔드 개발자가 한 팀을 구성한다.
- 도메인 단위로 기능을 구현하므로, 도메인 단위로 기능을 확장할 수 있는 MSA가 적합하다.

## 마이크로서비스 아키텍처
- 모놀리식 아키텍처에 대응되는 아키텍처로 하나의 큰 시스템을 독립적이고 작은 모듈로 분리하고 서로 약한 결합으로 묶여 상호작용하는 아키텍처
- MSA의 가장 큰 장점은 수평적 확장성이다.
- 개발이 복잡하다. 모듈을 독립적으로 나누는 것도 어렵고, 모듈 하나에 장애가 발생했을 경우에 대한 방어 코드도 작성해야한다. 그 밖에도 테스트와 디버깅이 어렵다.
- Multiple Database 및 트랜잭션 관리가 어려울 수 있다.
- 도커 같은 컨테이너 가상화 기술과 쿠버네티스 같은 오토 스케일링, 셀프 힐링, 트래픽 분배 등의 기능을 제공하는 오케스트레이션 도구가 필요하다.
- 또한 여러 모듈에서 생성되는 데이터를 중앙에서 관리할 수 있도록 Kafka, Redis 같은 메시지 큐도 필요하다.
- 그리고 모듈 간 통신이 빈번하기 때문에 기존 REST API 통신보다 더 빠른 통신 기술이 필요하며, gRPC를 사용할 수 있다.


## Reactive Programming
- 어떤 이벤트가 발생하거나 상태가 변했을 때 특정 코드를 시키는 프로그래밍 방식
- `Event Emitter`나 `State`를 구독하는 Publish/Subscribe 모델을 사용한다.
- 이벤트 기반 프로그래밍에는 `Reactive Stream API`의 구현체는 `RxJava`의 Observable, `Reactor`의 Mono, Flux가 있다
안드로이드 모바일에서도 `RxJava`, `LiveData`, `Coroutine` 등의 형태로 이미 Reactive Programming 패러다임을 적용하고 있다.

## Event Driven Architecture
- 이벤트가 발생했을 때 특정 작업을 수행하도록 하는 아키텍처
- MSA에서는 독립적이고 작은 여러 모듈이 서로 상호작용하는데, 이 때문에 특정 모듈에서 이벤트가 발생했을 때 다른 모듈의 로직을 실행해야하는 경우가 빈번하다.
- 특히 여러 모듈에서 발생하는 데이터를 `Kafka`, `Redis` 같은 메시지 큐에 집중화하고, 이를 구독하는 모듈에게 이벤트를 발생시키는 형태로 이벤트 기반 아키텍처를 구현한다,

## Apache Kafka
- `Publish/Subscribe` 모델의 메시지 큐
- 분산 코디네이터인 `Zookeeper`와 브로커 서버인 `Kafka` 여러 대로 클러스터를 구축할 수 있다.
- `Key-Value` 형식으로 메시지를 전송할 수 있다.
- `Producer`는 메시지를 생산하는 주체
- `Consumer`는 메시지를 소비하는 주체
- 메시지를 `Topic` 단위로 분류한다.
- Topic에 여러 `Partition`을 할당하여 병렬적으로 데이터를 생산할 수 있다.
- `Consumer Group`을 할당하여 배압 이슈를 해결할 수 있다. Consumer Group의 각 `Consumer`는 서로 다른 `Partition`에서 병렬적으로 데이터를 읽어온다.
- 기존 메시지 큐가 인메모리 방식으로 데이터를 저장하는 반면, `Kafka`는 온디스크에 데이터를 저장하기 때문에 영속성이 보장이 된다.
- `Replication`을 활용하여 Topic을 여러 노드에 분산 저장하면 고가용성을 높일 수 있다.


## gRPC
- google Remote Procedure Call
- 다른 서버의 메서드를 로컬 메서드처럼 호출하는 기술
- `프로토콜 버퍼`를 사용하는 인터페이스 프로젝트를 생성하고, `.proto` 확장자로 인터페이스 코드를 작성한 후 JAR 파일로 빌드한다.
- 이 결과물을 클라이언트 프로젝트와 서버 프로젝트에 임포트하여 사용할 수 있다.
- REST API는 HTTP 1.1을 사용하고 메시지 포맷으로 JSON을 사용한다.
- gRPC는 HTTP 2를 사용하고 메시지 포맷으로 프로토콜 버퍼를 사용한다.
- gRPC는 REST API에 비해 형식이 더욱 엄격하여 불필요한 논쟁을 줄인다.
- gRPC의 프로토콜 버퍼는 REST API의 JSON 직렬화보다 최대 8배 빼를 수 있다고 한다.

## Docker
- `Docker`는 컨테이너 가상화 기술이다.
- 도커를 사용하면 호스트 OS에 `Container`라는 격리된 공간을 제공받을 수 있다.
- `Docker Container`를 `Docker Image`로 빌드하면 도커가 설치된 어느 곳에든 쉽게 배포할 수 있다.
- 또한 `Kubernetes`같은 컨테이너 오케스트레이션 기술과 함께 사용하여 MSA를 쉽게 구축할 수 있다.
- 가상머신은 게스트 OS와 호스트 OS 사이에 하이퍼바이저가 위치하여 속도가 매우 느리다. 반면 `Docker`는 도커 엔진만을 거쳐 호스트 OS의 자원을 사용하기 때문에 속도가 훨씬 빠르다.

## Kubernetes
- 컨테이너 오케스트레이션 플랫폼으로 여러 물리적 서버를 논리적으로 하나의 서버처럼 클러스터링해준다.
- 쿠버네티스가 오브젝트를 여러 노드에 알아서 분배해서 배치해준다.
- 또한 오토스케일링을 통해 새로운 노드를 쉽게 추가할 수 있어 수평적 확장이 간편하다.
- 그 밖에도 특정 컨테이너가 다운되어도 자동 복구해주는 셀프 힐링
- 요청을 여러 노드와 컨테이너에 골고루 분배해주는 로드 밸런싱
- 무중단 배포를 위한 롤링 업데이트
- 이전 버전으로 쉽게 돌아가는 롤백
- 네트워크, 보안, 볼륨 등 다양한 기능을 제공한다.
- 쿠버네티스 `오브젝트`는 다음과 같다.
    - `노드`
        - 쿠버네티스 클러스터를 구성하는 호스트 하나
        - 여러 노드 중 하나를 마스터 노드로 설정하고 나머지를 워커 노드로 설정한다.
    - `팟`
        - 쿠버네티스에서는 컨테이너 애플리케이션의 기본 단위를 팟(Pod)이라고 한다.
        - 팟은 하나 이상의 도커 컨테이너로 구성된다.
    - `레플리카셋`
        - 동일한 팟 여러개를 쉽게 생성하고 관리할 수 있다.
        - 지정된 팟의 개수를 자동으로 유지하는 셀프 힐링을 제공한다.
    - `디플로이먼트`
        - 여러 팟을 롤링 업데이트하여 무중단 배포가 가능하게 한다.
        - 이전 배포로 쉽게 롤백할 수 있다.
    - `서비스`
        - 팟은 기본적으로 쿠버네티스 클러스터 내부에만 노출된다.
        - 서비스를 사용하면 팟을 클러스터 외부로 노출시킬 수 있다.
    - `네임스페이스`
        - 여러 오브젝트를 논리적으로 구성할 수 있다.
        - 예를 들어 `nginx-ingress`와 관련된 오브젝트는 `nginx-ingress` 네임스페이스에 위치한다.
        - `ArgoCD`와 관련된 오브젝트는 `argocd` 네임스페이스에 위치한다.
        - 네임스페이스 별로 다른 컨피그 맵과 시크릿을 적용할 수 있다.
    - `인그레스`
        - 팟 외부 노출
        - 서비스를 URL Path를 통한 포워딩
        - SSL/TLS를 제공하는 오브젝트다.
        - 인그레스 컨트롤러를 설치해야한다.

## Web Socket
- 양방향 데이터 통신을 위한 프로토콜
- TCP Socket이 OSI 4 Layer에서 동작하는 반면 WebSocket은 OSI 7 Layer의 `HTTP` 프로토콜 위에서 동작한다.
- 먼저 HTTP 프로토콜로 Websocket Handshaking을 하여 연결을 수립하고, 그 다음은 Websocket 프로토콜로 양방향으로 통신한다.

## SOLID 원칙
객체지향 프로그래밍 및 설계에서 유지 보수가 쉽고 변경에 유연하게 대응할 수 있도록 적용하는 원칙

### SRP
- 단일 책임 원칙(Single Responsibility Priciple)
- 한 클래스는 하나의 책임만 가져야한다. 
- 즉 하나의 클래스는 해당 클래스와 연관된 기능들만 가져야하며, 응집도를 높이고 결합도를 낮추는 것과 관련된다.
- 예를 들어 계산기 클래스는 덧셈, 뺄셈, 곱셈, 나눗셈 기능만을 포함해야한다.

### OCP
- 개방 폐쇠 원칙(Open Closed Priciple)
- 변경에는 닫혀있으나 확장에는 열려있다.
- 즉 요구사항이 변경되었을 때 기존 코드를 수정하지 않고도 확장의 형태로 재사용할 수 있어야한다.
- 요구사항이 변경될 수도 있는 부분을 인터페이스로 정의하고, 변경된 요구사항은 새로은 구현체로 구현한다.
- 다형성이 핵심이다.
- 변경될 부분과 절대 변경되지 않을 부분을 구분하는게 핵심이다.

### LSP
- 리스코프 치환 원칙(Liskov Substitution Principle)
- 부모 클래스 타입의 변수에 자식 클래스의 인스턴스를 넣어도 잘 작동해야한다.
- 자식 클래스는 부모 클래스의 기능을 오버라이딩하기보단 새롭게 메소드를 정의하는 형태로 구현해야한다.

### ISP
- 인터페이스 분리 원칙(Interface Segregation Principle)
- 클래스는 자신이 사용하지 않는 인터페이스를 implements 하지 말아야한다.
- 또한 하나의 인터페이스에 선언을 몰아넣는 것보다 연관된 작은 단위로 인터페이스에 분리하여 필요한 인터페이스만 구현하는 것이 낫다.

### DIP
- 의존관계 역전 원칙(Dependency Inversion Principle)
- 의존성 주입의 기반이 되는 원칙
- 변수의 타입은 인터페이스로 정의하고 의존성 주입을 통해 구현체를 할당하는 것
- OOP의 다형성이 기반이 된다.