---
title: "운영체제"
lang: ko
showOnSidebar: true
sidebarDepth: 0
---

# Table of Contents
[[toc]]

## 프로세스

## 프로세스와 스레드
### 프로세스
- 메모리에 로드되어 연속적으로 실행되고 있는 프로그램
- 네 가지 영역으로 구분된다.
    - `Code`: 컴파일된 코드가 저장되는 영역
    - `Data`: 전역변수, Static 변수가 저장되는 영역
    - `Stack`: 지역변수, 매개변수가 저장되는 영역
    - `Heap`: 동적 할당 영역

## PCB
- Process Control Block
- 다중 프로세스 환경에서 각 프로세스를 구분하기 위한 프로세스 정보
- 운영체제가 `Context Switching`을 할 때 필요로한다.
- PID, 상태, 스케쥴링 우선순위 등의 정보를 저장한다.

### 스레드
- 프로세스의 `실행 흐름`
- 하나의 프로세스는 여러 `실행 흐름`을 가질 수 있으며, 이를 `멀티 스레드`라고 한다.
- 모든 스레드는 `Code`, `Data`, `Heap`영역을 공유하지만 각각의 `Stack`을 유지한다.

### 인터럽트
- 한 프로세스가 수행 중일 때 다른 프로세스를 수행하기 위하여 현재 프로세스를 중지하거나, 입출력에 의해 현재 프로세스를 중단시키는 것
- 인터럽트의 처리과정
    1. 인터럽트가 발생하면 운영체제가 현재의 프로세스 상태를 저장하고 인터럽트를 처리한다.
    2. 이전 프로세스로 복구한다.

### Context Switching
- 현재 프로세스, 스레드의 상태를 저장하고 다른 프로세스, 스레드로 제어권을 넘기는 작업

### 멀티 프로세스 대신 멀티 스레드
- 멀티 프로세스의 `Context Swtiching` 비용이 더 크다.
- 멀티 스레드는 `Stack` 영역만 스위칭하면 되지만 멀티 프로세스는 `Code`, `Data`, `Heap` 영역까지 스위칭해야하기 때문이다.

### 공유자원
- 멀티 프로세스 환경에서는 여러 프로세스가 하나의 자원에 접근할 수 있다. 이를 `공유자원`이라고 한다.
- `임계 영역(Critical Section)`이라고도 한다.
- 공유자원은 한 순간에 하나의 프로세스만 접근할 수 있도록 해야하는데 이를 `동기화`라고 한다.

### 동기화
- 멀티 스레드 환경에서 한 순간에는 하나의 스레드만 공유자원에 접근할 수 있도록 하는 것.
- 동기화에는 다음과 같은 방법이 있다.

### Semaphore, Mutex
둘 다 한 순간에 하나의 프로세스, 스레드만 공유 자원에 접근하도록 하는 기술이다. 하나의 프로세스, 스레드가 공유 자원에 접근하고 있을 때, 다른 프로세스, 스레드가 접근하지 못하도록 `Lock`을 건다.
- `Mutex`: 한 순간에 하나의 프로세스, 스레드만 공유자원에 접근할 수 있다.
- `Process`: 정해진 수의 프로세스, 스레드만 공유자원에 접근할 수 있다. 

### 데드락
- 프로세스들이 서로의 자원을 점유한 상태에서 상대방의 자원을 무한정 기다리는 상태


## 블로킹과 논블로킹
### 블로킹
`함수 A`에서 `함수 B`를 호출한다고 가정하자. `함수 A` 실행 도중에 `함수 B`를 호출했을 때 `함수 B`가 끝날 때까지 기다렸다가 남은 부분을 실행하는 것을 `블로킹`이라고 한다.

### 논블로킹
`함수 A` 실행 도중에 `함수 B`를 호출했을 때 `함수 B`가 끝날 때까지 기다리지 않고 자신의 실행흐름을 수행하는 것을 `논블로킹`이라고 한다.


## 동기와 비동기
### 동기
`함수 A`에서 `함수 B`를 호출한다고 가정하자. `함수 A` 실행 도중에 `함수 B`를 호출했을 때 `함수 B`가 끝날 때까지 기다렸다가 남은 부분을 실행하면 두 함수 사이에 연관 관계가 있기 때문에 `동기화`되었다고 한다.

### 비동기
`함수 A` 실행 도중에 `함수 B`를 호출했을 때 `함수 B`가 끝날 때까지 기다리지 않고 자신의 실행흐름을 수행하기 때문에 연관관계가 없으며, 이를 `비동기`라고 한다.

결국 `블로킹/논블로킹`, `동기/비동기`는 관점의 차이이며, 일반적인 시스템은 `동기/블로킹 모델`과 `비동기/논블로킹` 모델로 구분된다. `비동기/논블로킹` 모델에서는 일반적으로 호출하는 함수의 종료 시점을 알 수 없기 때문에 종료 시점에 실행할 코드를 콜백, 람다 형태로 전달한다.

### CPU 스케줄링
- CPU는 메모리에 로드된 여러 프로세스를 우선순위대로 처리해야한다
- 비선점형
    - FIFO
    - SJF(Shortest Job First)
        - 실행 시간 추정치가 가장 작은 작업을 먼저 수행
        - 실행 시간이 짧은 작업은 무기한 연장되기 때문에 에이징 기법을 사용
- 선점형
    - Round Robin
        - 일정한 시간 만큼 돌아가면서 실행
    - SRT (Shortest Remaining Time)
        - 남아있는 실행 시간의 추정치가 가장 작은 프로세스를 먼저 수행
        - 현실적으로 남아있는 실행 시간 계산이 어렵다.

### 기아상태(Starvation)
- 우선순위가 낮은 프로세스가 실행 권한을 획득하지 못하는 상태
- `Aging`으로 해결할 수 있다.        

### 지역성
프로그램이 실행될 때 모든 영역을 골고루 참조하는게 아니라 특정 시간, 특정 공간에 집중적으로 참조한다는 특성
- `시간 지역성`: 최근 참조한 영역이 미래에도 계속 참조할 가능성이 높다.
- `공간 지역성`: 최근 참조한 지역의 근처를 계속 참조할 가능성이 높다.
`Cache Memory`가 지역성을 응용한 대표적인 기술

### 기억장치
- 레지스터
- 캐시 메모리 (Cache)
- 주기억 장치 (Memory)
- 보조기억 장치 (HDD, SSD)

### 가상 메모리
- 주기억장치는 가격도 비싸고 크기의 한계가 있다. 이러한 한계를 극복하고 주기억장치보다 더 큰 프로그램을 실행하기 위해 보조 기억장치의 영역 일부를 주기억장치처럼 사용하는 것
- 프로그램을 페이지라는 단위로 분할하고, 현재 실행중인 페이지만 주기억장치에 로드하여 실행한다.

## 쉘, 커널
- `쉘(Shell)`: 사용자의 명령어를 해석하여 커널에 전달한다. `bash`, `zsh` 같이 다양한 쉘이 존재한다.
- `커널(Kernel)`: 운영체제의 핵심으로 프로세스, 하드웨어, 입출력장치, 보호 및 보안 등을 담당한다. 

## 가상 머신과 도커 차이
가상 머신은 `호스트 OS`가 존재한다.