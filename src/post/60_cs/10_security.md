---
title: "보안"
lang: ko
showOnSidebar: true
sidebarDepth: 0
---

# Table of Contents
[[toc]]

# 보안, 정보보호
`보안`, `정보보호`에 대해 정리한다.

## 보안 분야
보안은 크게 네 분야로 나뉜다.
- 시스템 보안
- 네트워크 보안
- 어플리케이션 보안
- 정보보안 기술

## 보안의 삼대 요소 (CIA)
- `기밀성(Confidentiality)`: 인증되고 접근 권한도 있는 사용자만이 자원에 접근할 수 있다.
- `무결성(Integrity)`: 인증되지 않거나 접근 권한이 없는 사용자는 자원을 변경할 수 없다.
- `가용성(Availability)`: 인증되고 접근 권한도 있는 사용자는 언제든지 자원에 접근할 수 있다.

## 인증
`인증(Authentication)`은 아이디/패스워드 또는 토큰으로 사용자가 맞는지를 확인하는 것이다.

## 인가
`인가(Authorization)`는 자원에 대한 <u>접근 권한</u>을 지정하는 것으로 `접근 제어(Access Control)`라고도 한다. 인증된 사용자라도 특정 자원에 대한 권한이 없으면 접근할 수 없다. 스프링에서는 `역할(Role)` 또는 `권한(Authority)`로 인가를 구현할 수 있다.

## 악성 프로그램
`악성 코드`, `멀웨어(Malware)`라고도 하며, 악의적 목적으로 만든 모든 소프트웨어를 총칭한다. 악성 프로그램은 두 가지 기준으로 분류할 수 있다.
- 작동 방식에 따른 분류
- 특성에 따른 분류

### 작동 방식에 따른 분류
#### 바이러스
- 다른 코드에 기생하여 실행되기 때문에 자가실행 능력은 없다.
- 자기복제능력이 있어 다른 코드를 감염시킬 수 있다.
- 파일을 손상시킨다.

#### 웜
- 다른 코드에 기생하지 않고 독자적으로 실행된다.
- 네트워크 대역을 손상시킨다.

#### 트로이 목마
- 정상 소프트웨어로 위장한 악성 프로그램
- 사용자 정보를 유출하거나 자료를 파괴한다.

### 특성에 따른 분류
#### 스파이웨어
- 스파이 같은 행동을 하는 프로그램. 사용자의 동의없이 설치되어 중요한 정보를 유출한다.

#### 애드웨어
- 광고를 보여주는 프로그램

#### 백도어
- 뒷문이라는 뜻
- 정상적인 인증을 걸치지 않고 응용 프로그램 또는 시스템에 접근하여 컴퓨터 속의 정보를 빼내가거나 특정 작업을 하도록 제작된 프로그램

#### 루트킷
- 관리자 레벨의 접근을 가능하도록 하는 프로그램

#### 크립토마이너
- 사용자 몰래 설치되어 암호화폐를 채굴하는 프로그램.
- CPU 사용량을 높일 수 있다.

#### 랜섬웨어
- 인질과 소프트웨어의 합성어
- 컴퓨터 자원에 암호화를 걸고, 금품을 요구하는 프로그램

## DoS
- Denial of Service
- 서버에 과다한 요청을 보내서 네트워크 대역폭이나 시스템을 과부화시키는 것
- 하나의 호스트로 하나의 타겟을 공격하는 것

### TCP SYN Flooding
- 클라이언트가 3-way handshaking 과정에서 SYN를 보내면 서버는 SYN/ACK를 보내고 클라이언트의 응답을 처리하기 위해 자원을 점유하며 기다리게 된다.
- 이때 클라이언트가 다시 ACK를 보내지 않아 서버가 자원을 점유한 상태로 계속 기다리게 하는 공격
- 해결방법은 클라이언트와 서버 사이에 게이트를 위치시키고, 일정 시간이 지나도 클라이언트로부터 ACK가 도착하지 않으면 서버로 RST(Reset) 신호를 보내주도록 한다.

### UDP Flooding
- 클라이언트가 서버에 UDP 패킷을 계속 보내어 과부화시키는 것
- 해결방법은 방화벽을 통해 불필요한 서비스 요청을 차단한다.

### DDoS
- Distrubuted Denial of Service
- DoS는 하나의 호스트가 하나의 타겟을 공격한다면 DDos는 여러 호스트가 하나의 타겟을 분산 공격하는 것

### 해결방법
- 요청 수를 제한한다던지 특정 IP만 요청할 수 있도록 제한한다.
- 라우터의 방화벽, AWS의 IAM, 토큰 또는 JSON 인증 방식, Kubernetes의 ingress 기능을 사용할 수 있다.

## IP Spooping
- TCP 3-way handshaing 과정에서 제 3자가 서버의 `SYN/ACK`를 가로챈 후 클라이언트의 IP로 ACK를 보내서 세션을 연결하는 방법

## Sniffing
- 킁킁거리다.
- 네트워크 상에 지나다니느 패킷을 가로채서 내용을 확인하는 기술
- SSL, HTTPS, VPN 등의 기술을 사용하여 패킷을 암호화한다.

## SSL/TSL
- Socket Secure Layer/Transport Secure Layer
- 인증 및 데이터 암호화 전송을 제공하는 암호화 프로토콜
- 데이터 전송 전 SSL Shaking을 통해 암호화된 새션을 먼저 생성하고, 그 다음 데이터를 전송한다.
- 전송되는 데이터가 유출되어도 암호화되어있기 떄문에 기밀성이 보장된다.
- HTTPS, VPN 등에 사용된다.

## HTTPS
- HTTP Secure
- HTTP 통신이 SSL 암호화 프로토콜을 적용

## VPN
- Virtual Private Network
- 공공기관, 기업 등의 사설 네트워크를 SSL를 통해 구축하는 것
- 물리 네트워크 위에 가상의 네트워크를 구축하고, SSL를 적용하여 기밀성을 보장한다.

## SSO 
- 통합 인증(Single Sign-On)
- 한 번의 인증 과정으로 관련된 여러 애플리케이션에 접근할 수 있는 인증 방식

## 해시함수
- $hash(입력 문자열) = 출력 문자열 = 해시값 = 해시 코드$
- 출력 문자열로 입력 문자열을 찾을 수 없다는 `일방향성`을 가져야한다.
- 다른 입력 문자열에 대해 동일한 문자열이 나오지 않도록 `충돌 회피성`을 가져야한다.
- 해시함수는 `무결성 검증(위변조 방지)`에 활용된다.
    - 송신자는 데이터를 전송할 때 데이터에 대한 해시값을 뒤에 추가해서 전송한다.
    - 수신자는 데이터로 해시값을 구한 후, 전송받은 해시값과 비교하여 데이터가 변하지 않았다는 것을 증명한다.
- 다음과 같은 해시함수가 있다.
    - MD5
    - SHA-1


## 대칭키 암호화 알고리즘
- 송신자와 수신자가 동일한 `비밀키`를 가진다.
- 송신자는 평문을 비밀키로 암호화하여 전송하고, 수신자는 비밀키로 암호문을 복호화하여 평문을 얻는다.
- 암호화 알고리즘이 간단하여 빠르지만 `키 분배`의 문제가 있다. 즉 비밀키를 전달하는 과정에서 유출될 가능성이 있다.

다음과 같은 대칭형 암호화 알고리즘이 있다.
- `DES`: Data Encryption Standard
- `IDEA`: International Data Encryption Algorithm
- `AES`: Advanced Encryption Standard


## 비대칭키 암호화 알고리즘
- 송신자와 수신자가 서로 다른 키를 가지는 암호화 알고리즘
- 개인키로 암호화한 암호문을 공개키로 복호화할 수 있으며, 공개키로 암호화한 암호문을 개인키로 복호화할 수도 있다.
- 수신자가 `개인키`와 `공개키`를 생성한다.
- `개인키`는 수신자만 가지고 있으며, 수신자는 `공개키`를 여러 송신자에게 분배한다.
- 송신자는 평문을 공개키로 암호화하여 전송하고, 수신자는 개인키로 암호문을 복호화하여 평문을 얻는다.
- 암호화 알고리즘이 복잡하기 때문에 속도가 느리다.
- 반면 공개키 분배가 쉽다.
- 따라서 대칭키 암호화 알고리즘의 비밀키를 분배하는데 사용된다.
- 다음과 같은 비대칭키 암호화 알고리즘이 있다. 
    - `Diffie-Hellman`: 이산대수 문제의 어러움
    - `RSA`: 소인수분해 
- 비대칭키 암호화 알고리즘 다음 분야에 활용된다.
    - 암호화
    - 전자서명


## 전자서명
- `무결성(위변조 방지)`, `송신 부인방지`, `개인식별`, `인증(송신자 확인)`에 사용된다.
- 송신자는 평문으로 해시값을 만든다.
- 송신자는 개인키로 해시값을 암호화하여 암호문을 만든 후 평문과 암호문을 함께 보낸다.
- 수신자는 공개키로 암호문을 복호화하여 해시값을 얻는다.
- 수신자는 전송된 해시값과 평문으로 만든 해시값을 비교하여 무결성을 확인할 수 있다.
- 또한 복호화에 성공했다는 것은 송신자가 올바른 개인키로 암호화했다는 의미이기 때문에 송신 부인방지, 송신자 개인식별, 인증(송신자 확인)에 성공한다.

## PKI와 공동인증서
- Public Key Infrastructure (공개키 기반구조)
- 공동인증서 발급과 인증을 위해 구축한 인프라
- 공동인증서 발급 절차
    1. 사용자는 신분증, 계좌번호 등으로 본인을 인증하고 은행, 증권사 같은 등록대행기관(RA)에 공동인증서 발급을 요청한다. 이때 사용자는 개인키를 암호화하는데 사용하는 비밀번호를 함께 제공한다.
    2. 등록대행기관은 인증서에게 공동인증서 발급을 요청한다.
    3. 등록대행기관은 금융결제원, 코스콤 같은 인증기관(CA)에 공동인증서 발급을 요청한다. 
    4. 인증기관은 사용자의 개인키와 공개키를 생성한다.
    5. 인증기관은 사용자 정보, 만료기간 등의 정보 등을 사용자의 개인키로 암호화한다.
    6. 인증기관은 개인키로 암호화한 암호문과 사용자 공개키를 합친 후  전자서명을 해서 공동인증서를 만든다.
    6. 인증기관은 사용자가 제공한 비밀번호로 사용자의 개인키를 암호화한다.
    6. 인증기관은 <b><u>공동인증서</u></b>와 <b><u>사용자 개인키를 암호화한 암호문</u></b>를 사용자에게 발급한다.

- 공동인증서 인증 절차
    1. 사용자는 <b><u>공동인증서</u></b>, <b><u>사용자 개인키를 암호화한 암호문</u></b>, <b><u>개인키 비밀번호</u></b>를 제공한다.
    2. 인증기관은 본인이 서명한 공동인증서인지를 확인한다.
    3. 인증기관은 사용자의 공개키로 복호화하여 사용자 정보, 만료기간 등을 확인한다.

## 세션과 쿠키
- HTTP는 `비연결성(Connectionless)`과 `무상태성(Stateless)`을 가진다. 즉 클라이언트가 요청을 보내고 서버가 적절한 응답을 하면 바로 HTTP 연결이 끊어진다.
- `쿠키(Cookie)`와 `세션(Session)`을 사용하면 HTTP에 연결성과 상태를 부여할 수 있다.
- 클라이언트가 첫 요청을 보내면 서버는 1:1로 대응되는 쿠키와 세션을 생성한다. 
- 서버는 세션을 메모리나 온디스크 데이터베이스에서 저장하며, 쿠키를 클라이언트에 보낸다.
- 클라이언트는 쿠키를 브라우저에 저장한다.
- 클라이언트는 다음 요청부터 쿠키를 헤더에 함께 보낸다.
- 서버는 이 쿠키를 세션과 비교하여 일치하는지 확인한다.
- `쿠키-세션`은 ID/password 인증 방식에 주로 활용된다.
- 세션을 인메모리 방식으로 관리하면 서버가 재시작될 때 사라지기 때문에 `Redis` 같은 데이터베이스에서 관리한다.
- 세션을 유지하는 것은 서버에 부담을 줄 수 있기 때문에 요즘에는 `토큰 기반 인증`도 많이 사용한다.

## JWT
- Json Web Token
- JSON 객체를 사용해서 토큰 자체에 정보를 저장하고 있는 토큰
- 사용자 정보로 생성한 토큰이 올바른지 검증할 수 있고, 만료시간도 설정할 수 있다.
- 토큰 기반 인증 방식에 활용된다.
- 특정 정보와 `Secret Key`를 사용하여 검증 가능하고 만료 기한이 있는 특수한 문자열을 생성할 수 있다.
- 보통 `토큰 인증방식`에서 `Access Token`과 `Refresh Token`을 생성하는데 사용한다.
- `쿠키 세션 인증방식`처럼 세션을 서버에 저장할 필요가 없기 때문에 서버의 부담이 줄어든다.

## OAuth 2.0
- 제 3자에게 인증을 위임하는 인증 방식
- 구글, 카카오 같은 간편 로그인도 `OAuth 2.0` 기반의 인증
- 순서
    - 어플리케이션을 구글, 카카오 같은 제 3자에게 등록하고 `리다이렉션 URL`과 `API Key`를 발급받는다.
    - 개발자는 제 3자에게 발급받은 `API Key`를 어플리케이션에 등록한다.
    - 사용자가 어플리케이션으로 로그인하면 `리다이렉션 URL`로 이동하도록 구현한다.
    - 사용자가 제 3자의 로그인 페이지에서 인증에 성공하면 애플리케이션은 인증 여부와 사용자 정보를 받게 된다.

## SQL Injection
- 로그인 폼 같은 입력 위젯에 `DELETE`, `DROP`, `UPDATE` 같은 SQL을 삽입하여 서버에 전송하는 것
- 1차적으로 `Spring Validation`으로 입력값을 검증하고,
- 2차적으로 `Native SQL` 대신 `Spring Data JPA`나 `Query DSL`을 사용한다.

## XSS
- Cross-site Scripting
- 로그인 폼 같은 입력 위젯에 자바스크립트 코드를 넣어 실행시키는 것
- 서버 사이드 렌더링(JSP, mustache)에서는 XSS Filter와 같은 필터를 적용하여 입력 데이터를 검증한다.
- 클라이언트 사이드 렌더링(React, Vue)에서도 자체적인 XXS 공격 방지 기술이 있다.

## CSRF
- 사이트 간 요청 위조(Cross Site Request Forgery) 공격
- 클라이언트가 자신의 의지와는 무관하게 서버로 추가, 수정, 삭제 요청을 보내도록 하거나 위조된 페이지로 이동시키는 것
- URL의 path variable, query parameter 등을 분석한 후 이메일에 첨부된 링크를 누르면 서버로 원치않은 요청을 보내거나, 새로운 게시글의 링크를 누르면 서버로 원치 않는 요청을 보내거나 특정 사이트로 이동시키는 것
- 해결방법은 두 가지가 있다.
    - 서버에서 요청의 Referer 헤더가 도메인과 일치하는지를 체크한다.
    - 서버에서 CSRF 토큰을 발행해주고, 클라이언트는 요청을 보낼 때 `X-XSRF-TOKEN`헤더에 이 토큰을 함께 보낸다.
- Token 기반 인증에서는 고려할 필요가 없으며, 쿠키 세션 기반과 SSR을 사용할 때 고려해야한다.


## SOP
- 동일 출처 정책(Same Origin Policy)
- <u><b>브라우저가</b></u> 하나의 도메인에서 다른 도메인으로 통신하지 못하도록 차단하는 정책
- 예를 들어 `http://domainA.com` Ajax로 `http://domainB.com`에 HTTP 요청을 보내면 응답이 와도 브라우저가 이를 차단한다.
- 실제로는 브라우저가 `프로토콜`, `호스트`, `포트번호`까지 일치하는지 확인한다.

## CORS
- 교차 출처 리소스 공유(Cross Origin Resource Sharing)
- SOP 문제를 해결하기 위한 방법이 CORS
- 클라이언트와 서버가 정해진 헤더를 통해 교차 출처 리소스를 허용할지 결정하는 스펙
- 기본적으로 클라이언트는 HTTP 요청을 보낼 떄 `Origin` 헤더에 출처를 명시한다.
- 서버는 `Access-Control-Allow-Origin` 헤더에 허용할 출처를 명시하여 응답한다.
- 웹 브라우저는 서버로 부터 응답을 받았을 때 두 헤더값을 비교한 후 다르면 에러를 발생시킨다. 
- 따라서 서버에서 응답을 보낼 떄 `Access-Control-Allow-Origin` 헤더를 적절하게 설정해주어야 한다.
- `Spring`, `Express` 같은 웹 프레임워크는 `CORS`을 쉽게 제어하기 위한 다양한 방법을 제공한다. 
