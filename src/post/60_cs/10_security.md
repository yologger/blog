---
title: "보안"
lang: ko
showOnSidebar: true
sidebarDepth: 0
---

# Table of Contents
[[toc]]

# 보안, 정보보호
`보안`, `정보보호`에 대해 정리한다.

## 보안 분야
보안은 크게 네 분야로 나뉜다.
- 시스템 보안
- 네트워크 보안
- 어플리케이션 보안
- 정보보안 기술

## 보안의 삼대 요소 (CIA)
- `기밀성(Confidentiality)`: 인증되고 권한도 있는 사용자만이 자원에 접근할 수 있다.
- `무결성(Integrity)`: 인증되지 않거나 권한이 없는 사용자는 데이터를 변경할 수 없다.
- `가용성(Availability)`: 인증되고 권한도 있는 사용자는 언제든지 자원에 접근할 수 있다.

## 인증
`인증(Authentication)`은 아이디/패스워드 또는 토큰으로 사용자가 맞는지를 확인하는 것이다.

## 인가
`인가(Authorization)`는 자원에 대한 접근 권한을 지정하는 것으로 `접근 제어(Access Control)`이라고도 한다. 인증된 사용자라도 특정 자원에 대한 권한이 없으면 접근할 수 없다. 스프링에서는 `역할(Role)` 또는 `권한(Authority)`로 인가를 구현할 수 있다.

## 악성 프로그램
`악성 코드`, `멀웨어(Malware)`라고도 하며, 악의적 목적으로 만든 모든 소프트웨어를 총칭한다.

### 작동 방식에 따른 분류
#### 바이러스
- 다른 코드에 기생하여 실행되기 때문에 자가실행 능력은 없다.
- 자기복제능력이 있어 다른 코드를 감염시킬 수 있다.
- 파일을 손상시킨다.

#### 웜
- 다른 코드에 기생하지 않고 독자적으로 실행된다.
- 네트워크 대역을 손상시킨다.

#### 트로이 목마
- 정상 소프트웨어로 위장한 악성 프로그램
- 사용자 정보를 유출하거나 자료를 파괴한다.

### 특성에 따른 분류
#### 스파이웨어
- 스파이 같은 행동을 하는 프로그램. 사용자의 동의없이 설치되어 중요한 정보를 유출한다.

#### 애드웨어
- 광고를 보여주는 프로그램

#### 백도어
- 뒷문이라는 뜻
- 정상적인 인증을 걸치지 않고 응용 프로그램 또는 시스템에 접근하여 컴퓨터 속의 정보를 빼내가거나 특정 작업을 하도록 제작된 프로그램

#### 루트킷
- 관리자 레벨의 접근을 가능하도록 하는 프로그램

#### 크립토마이너
- 사용자 몰래 설치되어 암호화폐를 채굴하는 프로그램.
- CPU 사용량을 높일 수 있다.

#### 랜섬웨어
- 인질과 소프트웨어의 합성어
- 컴퓨터 자원에 암호화를 걸고, 금품을 요구하는 프로그램

## DoS
- Denial of Service
- 타겟에 과다한 요청을 보내서 네트워크 대역폭이나 시스템을 과부화시키는 것
- 하나의 호스트로 하나의 타겟을 공격하는 것

### TCP SYN Flooding
- 클라이언트가 3-way handshaking 과정에서 SYN를 보내면 서버는 SYN/ACK를 보내고 클라이언트의 응답을 처리하기 위해 자원을 점유하며 기다리게 된다.
- 이때 클라이언트가 다시 ACK를 보내지 않아 서버가 자원을 점유한 상태로 계속 기다리게 하는 공격
- 해결방법은 클라이언트와 서버 사이에 게이트를 위치시키고, 일정 시간이 지나도 클라이언트로부터 ACK가 도착하지 않으면 서버로 RST(Reset) 신호를 보내주도록 한다.

### UDP Flooding
- 클라이언트가 서버에 UDP 패킷을 계속 보내어 과부화시키는 것
- 해결방법은 방화벽을 통해 불필요한 서비스 요청을 차단한다.

### DDoS
- Distrubuted Denial of Service
- DoS는 하나의 호스트가 하나의 타겟을 공격한다면 DDos는 여러 호스트가 하나의 타겟을 분산 공격하는 것

### 해결방법
- 요청 수를 제한한다던지 특정 IP만 요청할 수 있도록 제한한다.
- 라우터의 방화벽, AWS의 IAM, 토큰 또는 JSON 인증 방식, Kubernetes의 ingress 기능을 사용할 수 있다.

## IP Spooping
- TCP 3-way handshaing 과정에서 제 3자가 서버의 `SYN/ACK`를 가로챈 후 클라이언트의 IP로 ACK를 보내서 세션을 연결하는 방법

## Sniffing
- 킁킁거리다.
- 네트워크 상에 지나다니느 패킷을 가로채서 내용을 확인하는 기술
- SSL, HTTPS, VPN 등의 기술을 사용하여 패킷을 암호화한다.

## SSL/TSL
- Socket Secure Layer/Transport Secure Layer
- 인증 및 데이터 암호화 전송을 제공하는 암호화 프로토콜
- 데이터 전송 전 SSL Shaking을 통해 암호화된 새션을 먼저 생성하고, 그 다음 데이터를 전송한다.
- 전송되는 데이터가 유출되어도 암호화되어있기 떄문에 기밀성이 보장된다.
- HTTPS, VPN 등에 사용된다.

## HTTPS
- HTTP Secure
- HTTP 통신이 SSL 암호화 프로토콜을 적용

## VPN
- Virtual Private Network
- 공공기관, 기업 등의 사설 네트워크를 SSL를 통해 구축하는 것
- 물리 네트워크 위에 가상의 네트워크를 구축하고, SSL를 적용하여 기밀성을 보장한다.

## SSO 
- 통합 인증(Single Sign-On)
- 한 번의 인증 과정으로 관련된 여러 애플리케이션에 접근할 수 있는 인증 방식

## 해시함수
- $hash(입력 문자열) = 출력 문자열 = 해시값 = 해시 코드$
- 출력 문자열로 입력 문자열을 찾을 수 없다는 `일방향성`을 가져야한다.
- 다른 입력 문자열에 대해 동일한 문자열이 나오지 않도록 `충돌 회피성`을 가져야한다.
- 해시함수는 `무결성 검증(위변조 방지)`에 활용된다.
    - 송신자는 데이터를 전송할 때 데이터에 대한 해시값을 뒤에 추가해서 전송한다.
    - 수신자는 데이터로 해시값을 구한 후, 전송받은 해시값과 비교하여 데이터가 변하지 않았다는 것을 증명한다.
- 다음과 같은 해시함수가 있다.
    - MD5
    - SHA-1


## 대칭키 암호화 알고리즘
- 송신자와 수신자가 동일한 `비밀키`를 가진다.
- 송신자는 평문을 비밀키로 암호화하여 전송하고, 수신자는 비밀키로 암호문을 복호화하여 평문을 얻는다.
- 암호화 알고리즘이 간단하여 빠르지만 `키 분배`의 문제가 있다. 즉 비밀키를 전달하는 과정에서 유출될 가능성이 있다.

다음과 같은 대칭형 암호화 알고리즘이 있다.
- `DES`: Data Encryption Standard
- `IDEA`: International Data Encryption Algorithm
- `AES`: Advanced Encryption Standard


## 비대칭키 암호화 알고리즘
- 송신자와 수신자가 서로 다른 키를 가지는 암호화 알고리즘
- 개인키로 암호화한 암호문을 공개키로 복호화할 수 있으며, 공개키로 암호화한 암호문을 개인키로 복호화할 수도 있다.
- 수신자가 `개인키`와 `공개키`를 생성한다.
- `개인키`는 수신자만 가지고 있으며, 수신자는 `공개키`를 여러 송신자에게 분배한다.
- 송신자는 평문을 공개키로 암호화하여 전송하고, 수신자는 개인키로 암호문을 복호화하여 평문을 얻는다.
- 암호화 알고리즘이 복잡하기 때문에 속도가 느리다.
- 반면 공개키 분배가 쉽다.
- 따라서 대칭키 암호화 알고리즘의 비밀키를 분배하는데 사용된다.
- 다음과 같은 비대칭키 암호화 알고리즘이 있다. 
    - `Diffie-Hellman`: 이산대수 문제의 어러움
    - `RSA`: 소인수분해 
- 비대칭키 암호화 알고리즘 다음 분야에 활용된다.
    - 암호화
    - 전자서명


## 전자서명
- `무결성(위변조 방지)`, `송신 부인방지`, `개인식별`, `인증(송신자 확인)`에 사용된다.
- 송신자는 평문으로 해시값을 만든다.
- 송신자는 개인키로 해시값을 암호화하여 암호문을 만든 후 평문과 암호문을 함께 보낸다.
- 수신자는 공개키로 암호문을 복호화하여 해시값을 얻는다.
- 수신자는 전송된 해시값과 평문으로 만든 해시값을 비교하여 무결성을 확인할 수 있다.
- 또한 복호화에 성공했다는 것은 송신자가 올바른 개인키로 암호화했다는 의미이기 때문에 송신 부인방지, 송신자 개인식별, 인증(송신자 확인)에 성공한다.

## PKI와 공동인증서
- Public Key Infrastructure (공개키 기반구조)
- 공동인증서 발급과 인증을 위해 구축한 인프라
- 공동인증서 발급 절차
    1. 사용자는 신분증, 계좌번호 등으로 본인을 인증하고 은행, 증권사 같은 등록대행기관(RA)에 공동인증서 발급을 요청한다. 이때 사용자는 개인키를 암호화하는데 사용하는 비밀번호를 함께 제공한다.
    2. 등록대행기관은 인증서에게 공동인증서 발급을 요청한다.
    3. 등록대행기관은 금융결제원, 코스콤 같은 인증기관(CA)에 공동인증서 발급을 요청한다. 
    4. 인증기관은 사용자의 개인키와 공개키를 생성한다.
    5. 인증기관은 사용자 정보, 만료기간 등의 정보 등을 사용자의 개인키로 암호화한다.
    6. 인증기관은 개인키로 암호화한 암호문과 사용자 공개키를 합친 후  전자서명을 해서 공동인증서를 만든다.
    6. 인증기관은 사용자가 제공한 비밀번호로 사용자의 개인키를 암호화한다.
    6. 인증기관은 <b><u>공동인증서</u></b>와 <b><u>사용자 개인키를 암호화한 암호문</u></b>를 사용자에게 발급한다.

- 공동인증서 인증 절차
    1. 사용자는 <b><u>공동인증서</u></b>, <b><u>사용자 개인키를 암호화한 암호문</u></b>, <b><u>개인키 비밀번호</u></b>를 제공한다.
    2. 인증기관은 본인이 서명한 공동인증서인지를 확인한다.
    3. 인증기관은 사용자의 공개키로 복호화하여 사용자 정보, 만료기간 등을 확인한다.

## OAuth 2
- 제 3자에게 인증을 위임하는 인증 방식
- 구글, 카카오 같은 간편 로그인도 OAuth 2.0 기반의 인증
- 순서
    1. 어플리케이션을 구글, 카카오 같은 제 3자에게 등록하고 리다이렉션 URL과 API Key를 발급받는다.
    2. 개발자는 제 3자에게 발급받은 API Key를 어플리케이션에 등록한다.
    3. 사용자가 어플리케이션으로 로그인하면 리다이렉션 URL로 이동하도록 구현한다.
    4. 사용자가 제 3자의 로그인 페이지에서 인증에 성공하면 애플리케이션은 인증 여부와 사용자 정보를 받게 된다.

## JWT
- Json Web Token
- JSON 객체를 사용해서 토큰 자체에 정보를 저장하고 있는 토큰
- 사용자 정보로 생성한 토큰이 올바른지 검증할 수 있고, 만료시간도 설정할 수 있다.
- 토큰 기반 인증 방식에 활용된다.

## SQL Injection 
- 로그인 폼 같은 입력 위젯에 DELETE, DROP, UPDATE 같은 SQL을 삽입하여 서버에 전송하는 것
- 1차적으로 Spring Validation으로 입력값을 검증하고,
- 2차적으로 Native SQL 대신 Spring Data JPA나 Query DSL을 사용한다.

## XSS
- Cross-site Scripting
- 로그인 폼 같은 입력 위젯에 자바스크립트 코드를 넣어 실행시키는 것
- 서버 사이드 렌더링(JSP, mustache)에서는 XSS Filter와 같은 필터를 적용하여 입력 데이터를 검증한다.
- 클라이언트 사이드 렌더링(React, Vue)에서도 자체적인 XXS 공격 방지 기술이 있다.

## CSRF
- Cross-site Request Forgery(사이트 간 요청 위조)
- 사용자가 자신의 의도와는 무관하게 공격자가 의도한 행위를 서버에 요청하도록 하는 공격
- 도메인 주소의 경로를 분석하여 특정 페이지로 이동시킨다던지, HTTP GET 메소드의 쿼리 파라미터 패턴을 파악하여 데이터베이스를 변경한다든지 할 수 있다.
- HTTP Request Header의 `Referer`를 사용하여 해결할 수 있다.
- `Referer`는 현재 요청된 페이지의 이전 웹페이지 주소를 포함한다.
- 이 헤더를 사용하여 정해진 도메인, 정해진 경로, 정해진 순서로 접속한 요청만을 허용하는 것이다.
